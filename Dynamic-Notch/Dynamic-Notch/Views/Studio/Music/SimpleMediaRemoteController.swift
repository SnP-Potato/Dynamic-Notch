//
//  SimpleMediaRemoteController.swift
//  Dynamic-Notch
//
//  Created by PeterPark on 8/5/25.
//

//import Foundation
//import Combine
//
//class SimpleMediaRemoteController: ObservableObject {
//    @Published var songTitle: String = ""
//    @Published var artistName: String = ""
//    @Published var albumName: String = ""
//    @Published var isPlaying: Bool = false
//    @Published var albumArtwork: Data? = nil
//    @Published var currentTime: Double = 0
//    @Published var duration: Double = 0
//    @Published var bundleIdentifier: String = ""
//    
//    // MediaRemote Ìï®ÏàòÎì§
//    private let MRMediaRemoteGetNowPlayingInfo: @convention(c) (DispatchQueue, @escaping ([String: Any]) -> Void) -> Void
//    private let MRMediaRemoteRegisterForNowPlayingNotifications: @convention(c) (DispatchQueue) -> Void
//    private let MRMediaRemoteSendCommand: @convention(c) (Int, AnyObject?) -> Void
//    private let MRMediaRemoteGetNowPlayingApplicationIsPlaying: @convention(c) (DispatchQueue, @escaping (Bool) -> Void) -> Void
//    
//    init?() {
//        // MediaRemote ÌîÑÎ†àÏûÑÏõåÌÅ¨ Î°úÎìú
//        guard let bundle = CFBundleCreate(
//            kCFAllocatorDefault,
//            NSURL(fileURLWithPath: "/System/Library/PrivateFrameworks/MediaRemote.framework")),
//              
//        let MRMediaRemoteGetNowPlayingInfoPointer = CFBundleGetFunctionPointerForName(
//            bundle, "MRMediaRemoteGetNowPlayingInfo" as CFString),
//        let MRMediaRemoteRegisterForNowPlayingNotificationsPointer = CFBundleGetFunctionPointerForName(
//            bundle, "MRMediaRemoteRegisterForNowPlayingNotifications" as CFString),
//        let MRMediaRemoteSendCommandPointer = CFBundleGetFunctionPointerForName(
//            bundle, "MRMediaRemoteSendCommand" as CFString),
//        let MRMediaRemoteGetNowPlayingApplicationIsPlayingPointer = CFBundleGetFunctionPointerForName(
//            bundle, "MRMediaRemoteGetNowPlayingApplicationIsPlaying" as CFString)
//        else {
//            print("‚ùå MediaRemote ÌîÑÎ†àÏûÑÏõåÌÅ¨Î•º Î°úÎìúÌï† Ïàò ÏóÜÏäµÎãàÎã§.")
//            return nil
//        }
//        
//        // Ìï®Ïàò Ìè¨Ïù∏ÌÑ∞ Î≥ÄÌôò
//        self.MRMediaRemoteGetNowPlayingInfo = unsafeBitCast(
//            MRMediaRemoteGetNowPlayingInfoPointer,
//            to: (@convention(c) (DispatchQueue, @escaping ([String: Any]) -> Void) -> Void).self
//        )
//        self.MRMediaRemoteRegisterForNowPlayingNotifications = unsafeBitCast(
//            MRMediaRemoteRegisterForNowPlayingNotificationsPointer,
//            to: (@convention(c) (DispatchQueue) -> Void).self
//        )
//        self.MRMediaRemoteSendCommand = unsafeBitCast(
//            MRMediaRemoteSendCommandPointer,
//            to: (@convention(c) (Int, AnyObject?) -> Void).self
//        )
//        self.MRMediaRemoteGetNowPlayingApplicationIsPlaying = unsafeBitCast(
//            MRMediaRemoteGetNowPlayingApplicationIsPlayingPointer,
//            to: (@convention(c) (DispatchQueue, @escaping (Bool) -> Void) -> Void).self
//        )
//        
//        print("‚úÖ MediaRemote Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ")
//        setupNotifications()
//        updateNowPlayingInfo()
//        updatePlayingState()
//    }
//    
//    private func setupNotifications() {
//        MRMediaRemoteRegisterForNowPlayingNotifications(DispatchQueue.main)
//        
//        let notifications = [
//            "kMRMediaRemoteNowPlayingInfoDidChangeNotification",
//            "kMRMediaRemoteNowPlayingApplicationDidChangeNotification",
//            "kMRMediaRemoteNowPlayingApplicationIsPlayingDidChangeNotification"
//        ]
//        
//        for notification in notifications {
//            NotificationCenter.default.addObserver(
//                self,
//                selector: #selector(updateNowPlayingInfo),
//                name: NSNotification.Name(notification),
//                object: nil
//            )
//        }
//        
//        NotificationCenter.default.addObserver(
//            self,
//            selector: #selector(updatePlayingState),
//            name: NSNotification.Name("kMRMediaRemoteNowPlayingApplicationIsPlayingDidChangeNotification"),
//            object: nil
//        )
//    }
//    
//    @objc func updateNowPlayingInfo() {
//        MRMediaRemoteGetNowPlayingInfo(DispatchQueue.main) { [weak self] info in
//            DispatchQueue.main.async {
//                // ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏ Í∞ÑÏÜåÌôî
//                if !info.isEmpty {
//                    print("üéµ MediaRemote Ï†ïÎ≥¥ ÏàòÏã†: \(info.keys.joined(separator: ", "))")
//                }
//                
//                // Ï†úÎ™© Ï∞æÍ∏∞
//                if let title = info["kMRMediaRemoteNowPlayingInfoTitle"] as? String {
//                    self?.songTitle = title
//                    print("‚úÖ Ï†úÎ™©: '\(title)'")
//                }
//                
//                // ÏïÑÌã∞Ïä§Ìä∏ Ï∞æÍ∏∞
//                if let artist = info["kMRMediaRemoteNowPlayingInfoArtist"] as? String {
//                    self?.artistName = artist
//                    print(" ÏïÑÌã∞Ïä§Ìä∏: '\(artist)'")
//                }
//                
//                // Ïï®Î≤î Ï∞æÍ∏∞
//                if let album = info["kMRMediaRemoteNowPlayingInfoAlbum"] as? String {
//                    self?.albumName = album
//                }
//                
//                // ÏãúÍ∞Ñ Ï†ïÎ≥¥
//                if let time = info["kMRMediaRemoteNowPlayingInfoElapsedTime"] as? Double {
//                    self?.currentTime = time
//                }
//                
//                if let duration = info["kMRMediaRemoteNowPlayingInfoDuration"] as? Double {
//                    self?.duration = duration
//                }
//                
//                // Ïï®Î≤î ÏïÑÌä∏
//                if let artData = info["kMRMediaRemoteNowPlayingInfoArtworkData"] as? Data {
//                    self?.albumArtwork = artData
//                }
//            }
//        }
//    }
//    
//    @objc func updatePlayingState() {
//        MRMediaRemoteGetNowPlayingApplicationIsPlaying(DispatchQueue.main) { [weak self] playing in
//            DispatchQueue.main.async {
//                self?.isPlaying = playing
//                print(" Ïû¨ÏÉù ÏÉÅÌÉú: \(playing ? "Ïû¨ÏÉù Ï§ë" : "Ï†ïÏßÄ")")
//            }
//        }
//    }
//    
//    // MARK: - Ï†úÏñ¥ Ìï®ÏàòÎì§
//    func play() {
//        MRMediaRemoteSendCommand(1, nil)
//        print(" Ïû¨ÏÉù Î™ÖÎ†π")
//    }
//    
//    func pause() {
//        MRMediaRemoteSendCommand(0, nil)
//        print(" Ï†ïÏßÄ Î™ÖÎ†π")
//    }
//    
//    func togglePlayPause() {
//        MRMediaRemoteSendCommand(2, nil)
//        print(" Ïû¨ÏÉù/Ï†ïÏßÄ ÌÜ†Í∏Ä")
//    }
//    
//    func nextTrack() {
//        MRMediaRemoteSendCommand(4, nil)
//        print(" Îã§Ïùå Í≥°")
//    }
//    
//    func previousTrack() {
//        MRMediaRemoteSendCommand(5, nil)
//        print(" Ïù¥Ï†Ñ Í≥°")
//    }
//    
//    deinit {
//        NotificationCenter.default.removeObserver(self)
//    }
//}


//
//  SimpleMediaRemoteController.swift
//  Dynamic-Notch
//
//  Enhanced version based on Stack Overflow research
//

//import Foundation
//import Combine
//
//class SimpleMediaRemoteController: ObservableObject {
//    @Published var songTitle: String = ""
//    @Published var artistName: String = ""
//    @Published var albumName: String = ""
//    @Published var isPlaying: Bool = false
//    @Published var albumArtwork: Data? = nil
//    @Published var currentTime: Double = 0
//    @Published var duration: Double = 0
//    @Published var bundleIdentifier: String = ""
//    @Published var playbackRate: Double = 1.0
//    @Published var isShuffled: Bool = false
//    @Published var repeatMode: Int = 0
//    
//    // MediaRemote Ìï®ÏàòÎì§
//    private let MRMediaRemoteGetNowPlayingInfo: (@convention(c) (DispatchQueue, @escaping ([String: Any]) -> Void) -> Void)?
//    private let MRMediaRemoteRegisterForNowPlayingNotifications: (@convention(c) (DispatchQueue) -> Void)?
//    private let MRMediaRemoteSendCommand: (@convention(c) (UInt32, [String: Any]?) -> Bool)?
//    private let MRMediaRemoteGetNowPlayingApplicationIsPlaying: (@convention(c) (DispatchQueue, @escaping (Bool) -> Void) -> Void)?
//    private let MRMediaRemoteGetNowPlayingClient: (@convention(c) (DispatchQueue, @escaping (AnyObject?) -> Void) -> Void)?
//    private let MRMediaRemoteSetElapsedTime: (@convention(c) (TimeInterval) -> Bool)?
//    
//    // ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ïù¥Î¶ÑÎì§
//    private let kMRMediaRemoteNowPlayingInfoDidChangeNotification = "kMRMediaRemoteNowPlayingInfoDidChangeNotification"
//    private let kMRMediaRemoteNowPlayingApplicationDidChangeNotification = "kMRMediaRemoteNowPlayingApplicationDidChangeNotification"
//    private let kMRMediaRemoteNowPlayingApplicationIsPlayingDidChangeNotification = "kMRMediaRemoteNowPlayingApplicationIsPlayingDidChangeNotification"
//    
//    // MRCommand Ï†ïÏùò (Stack OverflowÏóêÏÑú Ï∞∏Ï°∞Ìïú Í∞íÎì§)
//    private enum MRCommand: UInt32 {
//        case play = 0
//        case pause = 1
//        case togglePlayPause = 2
//        case stop = 3
//        case nextTrack = 4
//        case previousTrack = 5
//        case advanceShuffleMode = 6
//        case advanceRepeatMode = 7
//        case beginFastForward = 8
//        case endFastForward = 9
//        case beginRewind = 10
//        case endRewind = 11
//        case rewind15Seconds = 12
//        case fastForward15Seconds = 13
//        case rewind30Seconds = 14
//        case fastForward30Seconds = 15
//        case toggleRecord = 16
//        case skipForward = 17
//        case skipBackward = 18
//        case changePlaybackRate = 19
//        case rateTrack = 20
//        case likeTrack = 21
//        case dislikeTrack = 22
//        case bookmarkTrack = 23
//        case seekToPlaybackPosition = 45
//        case changeShuffleMode = 46
//        case changeRepeatMode = 47
//    }
//    
//    init?() {
//        // MediaRemote ÌîÑÎ†àÏûÑÏõåÌÅ¨ Î°úÎìú
//        guard let bundle = CFBundleCreate(
//            kCFAllocatorDefault,
//            NSURL(fileURLWithPath: "/System/Library/PrivateFrameworks/MediaRemote.framework")
//        ) else {
//            print("‚ùå MediaRemote ÌîÑÎ†àÏûÑÏõåÌÅ¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
//            return nil
//        }
//        
//        // Ìï®Ïàò Ìè¨Ïù∏ÌÑ∞Îì§ Í∞ÄÏ†∏Ïò§Í∏∞ - static Ìï®Ïàò ÏÇ¨Ïö©
//        self.MRMediaRemoteGetNowPlayingInfo = Self.loadFunction(
//            from: bundle,
//            name: "MRMediaRemoteGetNowPlayingInfo",
//            type: (@convention(c) (DispatchQueue, @escaping ([String: Any]) -> Void) -> Void).self
//        )
//        
//        self.MRMediaRemoteRegisterForNowPlayingNotifications = Self.loadFunction(
//            from: bundle,
//            name: "MRMediaRemoteRegisterForNowPlayingNotifications",
//            type: (@convention(c) (DispatchQueue) -> Void).self
//        )
//        
//        self.MRMediaRemoteSendCommand = Self.loadFunction(
//            from: bundle,
//            name: "MRMediaRemoteSendCommand",
//            type: (@convention(c) (UInt32, [String: Any]?) -> Bool).self
//        )
//        
//        self.MRMediaRemoteGetNowPlayingApplicationIsPlaying = Self.loadFunction(
//            from: bundle,
//            name: "MRMediaRemoteGetNowPlayingApplicationIsPlaying",
//            type: (@convention(c) (DispatchQueue, @escaping (Bool) -> Void) -> Void).self
//        )
//        
//        self.MRMediaRemoteGetNowPlayingClient = Self.loadFunction(
//            from: bundle,
//            name: "MRMediaRemoteGetNowPlayingClient",
//            type: (@convention(c) (DispatchQueue, @escaping (AnyObject?) -> Void) -> Void).self
//        )
//        
//        self.MRMediaRemoteSetElapsedTime = Self.loadFunction(
//            from: bundle,
//            name: "MRMediaRemoteSetElapsedTime",
//            type: (@convention(c) (TimeInterval) -> Bool).self
//        )
//        
//        // ÌïÑÏàò Ìï®ÏàòÎì§Ïù¥ Î°úÎìúÎêòÏóàÎäîÏßÄ ÌôïÏù∏
//        guard MRMediaRemoteGetNowPlayingInfo != nil,
//              MRMediaRemoteRegisterForNowPlayingNotifications != nil,
//              MRMediaRemoteSendCommand != nil else {
//            print("‚ùå ÌïÑÏàò MediaRemote Ìï®ÏàòÎì§ÏùÑ Î°úÎìúÌï† Ïàò ÏóÜÏäµÎãàÎã§.")
//            return nil
//        }
//        
//        print("‚úÖ MediaRemote Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ")
//        setupNotifications()
//        updateNowPlayingInfo()
//        updatePlayingState()
//        updateNowPlayingClient()
//    }
//    
//    // Ï†úÎÑ§Î¶≠ Ìï®Ïàò Î°úÎçî - staticÏúºÎ°ú Î≥ÄÍ≤Ω
//    private static func loadFunction<T>(from bundle: CFBundle, name: String, type: T.Type) -> T? {
//        guard let functionPointer = CFBundleGetFunctionPointerForName(bundle, name as CFString) else {
//            print("‚ùå \(name) Ìï®ÏàòÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
//            return nil
//        }
//        return unsafeBitCast(functionPointer, to: type)
//    }
//    
//    private func setupNotifications() {
//        MRMediaRemoteRegisterForNowPlayingNotifications?(DispatchQueue.main)
//        
//        let notifications = [
//            kMRMediaRemoteNowPlayingInfoDidChangeNotification,
//            kMRMediaRemoteNowPlayingApplicationDidChangeNotification,
//            kMRMediaRemoteNowPlayingApplicationIsPlayingDidChangeNotification
//        ]
//        
//        for notification in notifications {
//            NotificationCenter.default.addObserver(
//                self,
//                selector: #selector(handleNotification(_:)),
//                name: NSNotification.Name(notification),
//                object: nil
//            )
//        }
//    }
//    
//    @objc private func handleNotification(_ notification: Notification) {
//        print("üîî ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò ÏàòÏã†: \(notification.name.rawValue)")
//        
//        switch notification.name.rawValue {
//        case kMRMediaRemoteNowPlayingInfoDidChangeNotification:
//            updateNowPlayingInfo()
//            // Ïû¨ÏÉù Ï†ïÎ≥¥Í∞Ä Î≥ÄÍ≤ΩÎê† ÎïåÎèÑ Ïû¨ÏÉù ÏÉÅÌÉú ÌôïÏù∏
//            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { [weak self] in
//                self?.updatePlayingState()
//            }
//        case kMRMediaRemoteNowPlayingApplicationDidChangeNotification:
//            updateNowPlayingInfo()
//            updateNowPlayingClient()
//            updatePlayingState()
//        case kMRMediaRemoteNowPlayingApplicationIsPlayingDidChangeNotification:
//            updatePlayingState()
//        default:
//            break
//        }
//    }
//    
//    @objc func updateNowPlayingInfo() {
//        MRMediaRemoteGetNowPlayingInfo?(DispatchQueue.main) { [weak self] info in
//            DispatchQueue.main.async {
//                self?.processNowPlayingInfo(info)
//            }
//        }
//    }
//    
//    private func processNowPlayingInfo(_ info: [String: Any]) {
//        if !info.isEmpty {
//            print("üéµ MediaRemote Ï†ïÎ≥¥ ÏàòÏã†: \(info.keys.joined(separator: ", "))")
//            
//            // Î∞õÏùÄ Ï†ïÎ≥¥Ïùò Í∞íÎì§ÏùÑ Î°úÍ∑∏Î°ú ÌôïÏù∏
//            if let rate = info["kMRMediaRemoteNowPlayingInfoPlaybackRate"] as? Double {
//                print("üìä Ïû¨ÏÉù ÏÜçÎèÑ: \(rate)")
//            }
//            if let time = info["kMRMediaRemoteNowPlayingInfoElapsedTime"] as? Double {
//                print("‚è±Ô∏è Í≤ΩÍ≥º ÏãúÍ∞Ñ: \(time)")
//            }
//            if let duration = info["kMRMediaRemoteNowPlayingInfoDuration"] as? Double {
//                print("‚è±Ô∏è Ï¥ù ÏãúÍ∞Ñ: \(duration)")
//            }
//        }
//        
//        // Ï†úÎ™©
//        if let title = info["kMRMediaRemoteNowPlayingInfoTitle"] as? String {
//            self.songTitle = title
//        }
//        
//        // ÏïÑÌã∞Ïä§Ìä∏
//        if let artist = info["kMRMediaRemoteNowPlayingInfoArtist"] as? String {
//            self.artistName = artist
//        }
//        
//        // Ïï®Î≤î
//        if let album = info["kMRMediaRemoteNowPlayingInfoAlbum"] as? String {
//            self.albumName = album
//        }
//        
//        // ÏãúÍ∞Ñ Ï†ïÎ≥¥
//        let previousTime = self.currentTime
//        if let time = info["kMRMediaRemoteNowPlayingInfoElapsedTime"] as? Double {
//            self.currentTime = time
//        }
//        
//        if let duration = info["kMRMediaRemoteNowPlayingInfoDuration"] as? Double {
//            self.duration = duration
//        }
//        
//        // Ïû¨ÏÉù ÏÉÅÌÉú Ï∂îÎ°† - Ïó¨Îü¨ Î∞©Î≤ï Ï°∞Ìï©
//        var inferredIsPlaying = false
//        
//        // Î∞©Î≤ï 1: Ïû¨ÏÉù ÏÜçÎèÑÎ°ú ÌåêÎã®
//        if let rate = info["kMRMediaRemoteNowPlayingInfoPlaybackRate"] as? Double {
//            self.playbackRate = rate
//            if rate > 0 {
//                inferredIsPlaying = true
//                print("‚úÖ Ïû¨ÏÉù ÏÜçÎèÑÎ°ú Ïû¨ÏÉù Ï§ë ÌåêÎã®: \(rate)")
//            }
//        }
//        
//        // Î∞©Î≤ï 2: ÏãúÍ∞ÑÏù¥ Ï¶ùÍ∞ÄÌïòÍ≥† ÏûàÎäîÏßÄ ÌôïÏù∏ (Ïù¥Ï†Ñ ÏãúÍ∞ÑÍ≥º ÎπÑÍµê)
//        if !inferredIsPlaying && self.currentTime > previousTime && self.currentTime > 0 {
//            inferredIsPlaying = true
//            print("‚úÖ ÏãúÍ∞Ñ Ï¶ùÍ∞ÄÎ°ú Ïû¨ÏÉù Ï§ë ÌåêÎã®: \(previousTime) -> \(self.currentTime)")
//        }
//        
//        // Î∞©Î≤ï 3: Í≥° Ï†úÎ™©Ïù¥ ÏûàÍ≥† ÏãúÍ∞ÑÏù¥ 0Î≥¥Îã§ ÌÅ¨Î©¥ Ïû¨ÏÉù Ï§ëÏúºÎ°ú Í∞ÄÏ†ï
//        if !inferredIsPlaying && !self.songTitle.isEmpty && self.currentTime > 0 && self.duration > 0 {
//            inferredIsPlaying = true
//            print("‚úÖ Í≥° Ï†ïÎ≥¥ÏôÄ ÏãúÍ∞ÑÏúºÎ°ú Ïû¨ÏÉù Ï§ë ÌåêÎã®")
//        }
//        
//        // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
//        if self.isPlaying != inferredIsPlaying {
//            print("üîÑ Ïû¨ÏÉù ÏÉÅÌÉú Î≥ÄÍ≤Ω: \(self.isPlaying) -> \(inferredIsPlaying)")
//            self.isPlaying = inferredIsPlaying
//        }
//        
//        // ÏÖîÌîå Î™®Îìú
//        if let shuffleMode = info["kMRMediaRemoteNowPlayingInfoShuffleMode"] as? Int {
//            self.isShuffled = shuffleMode != 0
//        }
//        
//        // Î∞òÎ≥µ Î™®Îìú
//        if let repeatMode = info["kMRMediaRemoteNowPlayingInfoRepeatMode"] as? Int {
//            self.repeatMode = repeatMode
//        }
//        
//        // Ïï®Î≤î ÏïÑÌä∏
//        if let artData = info["kMRMediaRemoteNowPlayingInfoArtworkData"] as? Data {
//            self.albumArtwork = artData
//        }
//    }
//    
//    @objc func updatePlayingState() {
//        // MRMediaRemoteGetNowPlayingApplicationIsPlayingÏù¥ Ï†úÎåÄÎ°ú ÏûëÎèôÌïòÏßÄ ÏïäÏúºÎØÄÎ°ú
//        // ÎåÄÏã† nowPlayingInfoÎ•º ÌÜµÌï¥ ÏÉÅÌÉúÎ•º Ï∂îÎ°†ÌïòÎèÑÎ°ù Î≥ÄÍ≤Ω
//        print("üîÑ Ïû¨ÏÉù ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÎèÑ (nowPlayingInfo Î∞©Ïãù)")
//        updateNowPlayingInfo()
//    }
//    
//    private func updateNowPlayingClient() {
//        MRMediaRemoteGetNowPlayingClient?(DispatchQueue.main) { [weak self] client in
//            DispatchQueue.main.async {
//                // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑú Î≤àÎì§ ÏãùÎ≥ÑÏûê Ï∂îÏ∂ú ÏãúÎèÑ
//                if let client = client {
//                    // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Í∞ùÏ≤¥ÏóêÏÑú Î≤àÎì§ ÏãùÎ≥ÑÏûêÎ•º Í∞ÄÏ†∏Ïò§Îäî Î∞©Î≤ïÏùÄ ÎπÑÍ≥µÍ∞ú APIÏù¥ÎØÄÎ°ú
//                    // ÏïàÏ†ÑÌïòÍ≤å Ï≤òÎ¶¨Ìï¥Ïïº Ìï®
//                    let description = String(describing: client)
//                    if let range = description.range(of: "bundleIdentifier: ") {
//                        let startIndex = range.upperBound
//                        if let endRange = description[startIndex...].range(of: ",") {
//                            let bundleId = String(description[startIndex..<endRange.lowerBound])
//                            self?.bundleIdentifier = bundleId.trimmingCharacters(in: .whitespacesAndNewlines)
//                        }
//                    }
//                }
//            }
//        }
//    }
//    
//    // MARK: - Ï†úÏñ¥ Ìï®ÏàòÎì§
//    func play() {
//        let success = MRMediaRemoteSendCommand?(MRCommand.play.rawValue, nil) ?? false
//        print("‚ñ∂Ô∏è Ïû¨ÏÉù Î™ÖÎ†π \(success ? "ÏÑ±Í≥µ" : "Ïã§Ìå®")")
//        
//        // Î™ÖÎ†π ÌõÑ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
//        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { [weak self] in
//            self?.updatePlayingState()
//        }
//    }
//    
//    func pause() {
//        let success = MRMediaRemoteSendCommand?(MRCommand.pause.rawValue, nil) ?? false
//        print("‚è∏Ô∏è Ï†ïÏßÄ Î™ÖÎ†π \(success ? "ÏÑ±Í≥µ" : "Ïã§Ìå®")")
//        
//        // Î™ÖÎ†π ÌõÑ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
//        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { [weak self] in
//            self?.updatePlayingState()
//        }
//    }
//    
//    func togglePlayPause() {
//        let success = MRMediaRemoteSendCommand?(MRCommand.togglePlayPause.rawValue, nil) ?? false
//        print("‚èØÔ∏è Ïû¨ÏÉù/Ï†ïÏßÄ ÌÜ†Í∏Ä \(success ? "ÏÑ±Í≥µ" : "Ïã§Ìå®")")
//        
//        // ÌÜ†Í∏Ä ÌõÑ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ - ÏïΩÍ∞Ñ Îçî Í∏¥ ÏßÄÏó∞
//        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) { [weak self] in
//            self?.updatePlayingState()
//            self?.updateNowPlayingInfo()
//        }
//    }
//    
//    func nextTrack() {
//        _ = MRMediaRemoteSendCommand?(MRCommand.nextTrack.rawValue, nil)
//        print("‚è≠Ô∏è Îã§Ïùå Í≥°")
//    }
//    
//    func previousTrack() {
//        _ = MRMediaRemoteSendCommand?(MRCommand.previousTrack.rawValue, nil)
//        print("‚èÆÔ∏è Ïù¥Ï†Ñ Í≥°")
//    }
//    
//    func seek(to time: TimeInterval) {
//        _ = MRMediaRemoteSetElapsedTime?(time)
//        print("üïí ÏãúÍ∞Ñ ÌÉêÏÉâ: \(time)Ï¥à")
//    }
//    
//    func toggleShuffle() {
//        _ = MRMediaRemoteSendCommand?(MRCommand.advanceShuffleMode.rawValue, nil)
//        print("üîÄ ÏÖîÌîå ÌÜ†Í∏Ä")
//    }
//    
//    func toggleRepeat() {
//        _ = MRMediaRemoteSendCommand?(MRCommand.advanceRepeatMode.rawValue, nil)
//        print("üîÅ Î∞òÎ≥µ ÌÜ†Í∏Ä")
//    }
//    
//    func fastForward15() {
//        _ = MRMediaRemoteSendCommand?(MRCommand.fastForward15Seconds.rawValue, nil)
//        print("‚è© 15Ï¥à ÏïûÏúºÎ°ú")
//    }
//    
//    func rewind15() {
//        _ = MRMediaRemoteSendCommand?(MRCommand.rewind15Seconds.rawValue, nil)
//        print("‚è™ 15Ï¥à Îí§Î°ú")
//    }
//    
//    func setPlaybackRate(_ rate: Float) {
//        let options = ["kMRMediaRemoteOptionPlaybackRate": rate]
//        _ = MRMediaRemoteSendCommand?(MRCommand.changePlaybackRate.rawValue, options)
//        print("üéµ Ïû¨ÏÉù ÏÜçÎèÑ Î≥ÄÍ≤Ω: \(rate)")
//    }
//    
//    deinit {
//        NotificationCenter.default.removeObserver(self)
//    }
//}


//
//  SimpleMediaRemoteController.swift
//  Dynamic-Notch
//
//  Enhanced with mediaremote-adapter integration
//

import Foundation
import Combine

class SimpleMediaRemoteController: ObservableObject {
    @Published var songTitle: String = ""
    @Published var artistName: String = ""
    @Published var albumName: String = ""
    @Published var isPlaying: Bool = false
    @Published var albumArtwork: Data? = nil
    @Published var currentTime: Double = 0
    @Published var duration: Double = 0
    @Published var bundleIdentifier: String = ""
    @Published var playbackRate: Double = 1.0
    @Published var isShuffled: Bool = false
    @Published var repeatMode: Int = 0
    
    private var process: Process?
    private var pipe: Pipe?
    private var buffer = ""
    
    init?() {
        guard setupMediaRemoteAdapter() else {
            print("‚ùå MediaRemote AdapterÎ•º ÏÑ§Ï†ïÌï† Ïàò ÏóÜÏäµÎãàÎã§")
            return nil
        }
        
        print("‚úÖ MediaRemote Adapter Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ")
        updateNowPlayingInfo()
    }
    
    deinit {
        cleanup()
    }
    
    private func setupMediaRemoteAdapter() -> Bool {
        // BundleÏóêÏÑú Ïä§ÌÅ¨Î¶ΩÌä∏ÏôÄ ÌîÑÎ†àÏûÑÏõåÌÅ¨ Í≤ΩÎ°ú Ï∞æÍ∏∞
        guard let scriptURL = Bundle.main.url(forResource: "mediaremote-adapter", withExtension: "pl"),
              let frameworkPath = Bundle.main.privateFrameworksPath?.appending("/MediaRemoteAdapter.framework") else {
            print("‚ùå mediaremote-adapter.pl ÎòêÎäî ÌîÑÎ†àÏûÑÏõåÌÅ¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§")
            return false
        }
        
        // Ïä§Ìä∏Î¶º Î™®ÎìúÎ°ú Ïã§Ìñâ (Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏)
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/perl")
        process.arguments = [
            scriptURL.path,
            frameworkPath,
            "stream",
            "--debounce=50" // 50ms ÎîîÎ∞îÏö¥Ïä§Î°ú Ïä§Ìå∏ Î∞©ÏßÄ
        ]
        
        let pipe = Pipe()
        process.standardOutput = pipe
        process.standardError = pipe
        
        self.process = process
        self.pipe = pipe
        
        // Ï∂úÎ†• ÏùΩÍ∏∞ Ìï∏Îì§Îü¨ ÏÑ§Ï†ï
        pipe.fileHandleForReading.readabilityHandler = { [weak self] handle in
            let data = handle.availableData
            guard !data.isEmpty, let self = self else { return }
            
            if let chunk = String(data: data, encoding: .utf8) {
                self.buffer.append(chunk)
                self.processBuffer()
            }
        }
        
        // ÌîÑÎ°úÏÑ∏Ïä§ Ïã§Ìñâ
        do {
            try process.run()
            return true
        } catch {
            print("‚ùå MediaRemote Adapter Ïã§Ìñâ Ïã§Ìå®: \(error)")
            return false
        }
    }
    
    private func processBuffer() {
        while let range = buffer.range(of: "\n") {
            let line = String(buffer[..<range.lowerBound])
            buffer = String(buffer[range.upperBound...])
            
            if !line.isEmpty {
                processAdapterOutput(line)
            }
        }
    }
    
    private func processAdapterOutput(_ jsonLine: String) {
        guard let data = jsonLine.data(using: .utf8),
              let object = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let payload = object["payload"] as? [String: Any] else {
            return
        }
        
        let isDiff = object["diff"] as? Bool ?? false
        
        DispatchQueue.main.async { [weak self] in
            self?.updateFromPayload(payload, isDiff: isDiff)
        }
    }
    
    private func updateFromPayload(_ payload: [String: Any], isDiff: Bool) {
        // Ï†úÎ™©
        if let title = payload["title"] as? String {
            self.songTitle = title
            print("üéµ Ï†úÎ™©: \(title)")
        } else if !isDiff {
            self.songTitle = ""
        }
        
        // ÏïÑÌã∞Ïä§Ìä∏
        if let artist = payload["artist"] as? String {
            self.artistName = artist
            print("üë§ ÏïÑÌã∞Ïä§Ìä∏: \(artist)")
        } else if !isDiff {
            self.artistName = ""
        }
        
        // Ïï®Î≤î
        if let album = payload["album"] as? String {
            self.albumName = album
        } else if !isDiff {
            self.albumName = ""
        }
        
        // Ïû¨ÏÉù ÏÉÅÌÉú
        if let playing = payload["playing"] as? Bool {
            if self.isPlaying != playing {
                self.isPlaying = playing
                print("‚èØÔ∏è Ïû¨ÏÉù ÏÉÅÌÉú: \(playing ? "Ïû¨ÏÉù Ï§ë" : "Ï†ïÏßÄ")")
            }
        } else if !isDiff {
            self.isPlaying = false
        }
        
        // ÏãúÍ∞Ñ Ï†ïÎ≥¥
        if let time = payload["elapsedTime"] as? Double {
            self.currentTime = time
        } else if !isDiff {
            self.currentTime = 0
        }
        
        if let duration = payload["duration"] as? Double {
            self.duration = duration
        } else if !isDiff {
            self.duration = 0
        }
        
        // Ïû¨ÏÉù ÏÜçÎèÑ
        if let rate = payload["playbackRate"] as? Double {
            self.playbackRate = rate
        } else if !isDiff {
            self.playbackRate = 1.0
        }
        
        // ÏÖîÌîå Î™®Îìú
        if let shuffleMode = payload["shuffleMode"] as? Int {
            self.isShuffled = shuffleMode != 1 // 1Ïù¥ off, 2Í∞Ä on
        } else if !isDiff {
            self.isShuffled = false
        }
        
        // Î∞òÎ≥µ Î™®Îìú
        if let repeatMode = payload["repeatMode"] as? Int {
            self.repeatMode = repeatMode
        } else if !isDiff {
            self.repeatMode = 0
        }
        
        // Î≤àÎì§ ÏãùÎ≥ÑÏûê
        if let bundleId = payload["parentApplicationBundleIdentifier"] as? String ??
                           payload["bundleIdentifier"] as? String {
            self.bundleIdentifier = bundleId
        } else if !isDiff {
            self.bundleIdentifier = ""
        }
        
        // Ïï®Î≤î ÏïÑÌä∏
        if let artworkDataString = payload["artworkData"] as? String {
            self.albumArtwork = Data(base64Encoded: artworkDataString.trimmingCharacters(in: .whitespacesAndNewlines))
        } else if !isDiff {
            self.albumArtwork = nil
        }
    }
    
    // MARK: - Public Methods
    @objc func updateNowPlayingInfo() {
        // Ïä§Ìä∏Î¶º Î™®ÎìúÏóêÏÑúÎäî ÏûêÎèôÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ÎêòÎØÄÎ°ú Î≥ÑÎèÑ Ïï°ÏÖò Î∂àÌïÑÏöî
        // ÌïÑÏöîÏãú get Î™ÖÎ†πÏúºÎ°ú Ï¶âÏãú Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏûàÏùå
        executeCommand("get")
    }
    
    @objc func updatePlayingState() {
        // Ïä§Ìä∏Î¶º Î™®ÎìúÏóêÏÑú ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏
        updateNowPlayingInfo()
    }
    
    // MARK: - Ï†úÏñ¥ Ìï®ÏàòÎì§
    func play() {
        executeCommand("send", parameters: ["0"]) // kMRPlay = 0
        print("‚ñ∂Ô∏è Ïû¨ÏÉù Î™ÖÎ†π")
    }
    
    func pause() {
        executeCommand("send", parameters: ["1"]) // kMRPause = 1
        print("‚è∏Ô∏è Ï†ïÏßÄ Î™ÖÎ†π")
    }
    
    func togglePlayPause() {
        executeCommand("send", parameters: ["2"]) // kMRTogglePlayPause = 2
        print("‚èØÔ∏è Ïû¨ÏÉù/Ï†ïÏßÄ ÌÜ†Í∏Ä")
    }
    
    func nextTrack() {
        executeCommand("send", parameters: ["4"]) // kMRNextTrack = 4
        print("‚è≠Ô∏è Îã§Ïùå Í≥°")
    }
    
    func previousTrack() {
        executeCommand("send", parameters: ["5"]) // kMRPreviousTrack = 5
        print("‚èÆÔ∏è Ïù¥Ï†Ñ Í≥°")
    }
    
    func seek(to time: TimeInterval) {
        let microseconds = Int(time * 1_000_000)
        executeCommand("seek", parameters: ["\(microseconds)"])
        print("üïí ÏãúÍ∞Ñ ÌÉêÏÉâ: \(time)Ï¥à")
    }
    
    func toggleShuffle() {
        // ÏÖîÌîå Î™®Îìú ÌÜ†Í∏Ä (ÌòÑÏû¨ ÏÉÅÌÉúÏóê Îî∞Îùº)
        let newMode = isShuffled ? "1" : "2" // 1 = off, 2 = on
        executeCommand("shuffle", parameters: [newMode])
        print("üîÄ ÏÖîÌîå ÌÜ†Í∏Ä")
    }
    
    func toggleRepeat() {
        // Î∞òÎ≥µ Î™®Îìú ÏàúÌôò (off -> all -> one -> off)
        let newMode: String
        switch repeatMode {
        case 1: newMode = "3" // off -> all
        case 3: newMode = "2" // all -> one
        default: newMode = "1" // one -> off
        }
        executeCommand("repeat", parameters: [newMode])
        print("üîÅ Î∞òÎ≥µ ÌÜ†Í∏Ä")
    }
    
    func fastForward15() {
        executeCommand("send", parameters: ["13"]) // kMRFastForward15Seconds = 13
        print("‚è© 15Ï¥à ÏïûÏúºÎ°ú")
    }
    
    func rewind15() {
        executeCommand("send", parameters: ["12"]) // kMRRewind15Seconds = 12
        print("‚è™ 15Ï¥à Îí§Î°ú")
    }
    
    func setPlaybackRate(_ rate: Float) {
        // MediaRemoteÏóêÏÑú Ïû¨ÏÉù ÏÜçÎèÑ Î≥ÄÍ≤ΩÏùÄ Î≥µÏû°ÌïòÎØÄÎ°ú Íµ¨ÌòÑÌïòÏßÄ ÏïäÏùå
        print("üéµ Ïû¨ÏÉù ÏÜçÎèÑ Î≥ÄÍ≤ΩÏùÄ ÏßÄÏõêÎêòÏßÄ ÏïäÏäµÎãàÎã§")
    }
    
    // MARK: - Private Methods
    private func executeCommand(_ command: String, parameters: [String] = []) {
        guard let scriptURL = Bundle.main.url(forResource: "mediaremote-adapter", withExtension: "pl"),
              let frameworkPath = Bundle.main.privateFrameworksPath?.appending("/MediaRemoteAdapter.framework") else {
            return
        }
        
        // Î≥ÑÎèÑ ÌîÑÎ°úÏÑ∏Ïä§Î°ú Î™ÖÎ†π Ïã§Ìñâ
        let commandProcess = Process()
        commandProcess.executableURL = URL(fileURLWithPath: "/usr/bin/perl")
        
        var arguments = [scriptURL.path, frameworkPath, command]
        arguments.append(contentsOf: parameters)
        commandProcess.arguments = arguments
        
        do {
            try commandProcess.run()
            commandProcess.waitUntilExit()
        } catch {
            print("‚ùå Î™ÖÎ†π Ïã§Ìñâ Ïã§Ìå®: \(command) - \(error)")
        }
    }
    
    private func cleanup() {
        pipe?.fileHandleForReading.readabilityHandler = nil
        
        if let process = process, process.isRunning {
            process.terminate()
            process.waitUntilExit()
        }
        
        process = nil
        pipe = nil
    }
}
